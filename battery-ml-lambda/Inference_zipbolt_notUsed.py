{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a9248bae",
   "metadata": {
    "vscode": {
     "languageId": "plaintext"
    }
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import io\n",
    "import json\n",
    "import pickle\n",
    "import warnings\n",
    "from datetime import datetime, timedelta\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from tensorflow.keras.models import load_model\n",
    "from tensorflow.keras.optimizers import Adam\n",
    "\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "# ================= CONFIG =================\n",
    "\n",
    "MODEL_DIR = \"models\"\n",
    "DATASET_PATH = os.path.join(MODEL_DIR, \"d4.csv\")\n",
    "\n",
    "AUTOENCODER_PATH = os.path.join(MODEL_DIR, \"autoencoder_best.h5\")\n",
    "ISOLATION_FOREST_PATH = os.path.join(MODEL_DIR, \"isolation_forest.pkl\")\n",
    "SCALER_PATH = os.path.join(MODEL_DIR, \"scaler.pkl\")\n",
    "FEATURE_NAMES_PATH = os.path.join(MODEL_DIR, \"feature_names.json\")\n",
    "CONFIG_PATH = os.path.join(MODEL_DIR, \"config.json\")\n",
    "\n",
    "DEVICE_COLUMN = \"device_id\"\n",
    "RECENT_DATA_WINDOW_MINUTES = 20\n",
    "ROLL_WIN = 5\n",
    "\n",
    "# ================= LOAD MODELS ONCE =================\n",
    "\n",
    "autoencoder = load_model(AUTOENCODER_PATH, compile=False)\n",
    "autoencoder.compile(optimizer=Adam(0.001), loss=\"mse\")\n",
    "\n",
    "with open(SCALER_PATH, \"rb\") as f:\n",
    "    scaler = pickle.load(f)\n",
    "\n",
    "with open(FEATURE_NAMES_PATH, \"r\") as f:\n",
    "    feature_names = json.load(f)\n",
    "\n",
    "with open(ISOLATION_FOREST_PATH, \"rb\") as f:\n",
    "    isolation_forest = pickle.load(f)\n",
    "\n",
    "with open(CONFIG_PATH, \"r\") as f:\n",
    "    config = json.load(f)\n",
    "\n",
    "ae_threshold = float(config.get(\"autoencoder_threshold\", 0.0))\n",
    "current_thr = config.get(\"current_thresholds\", {})\n",
    "temp_thr = config.get(\"temperature_thresholds\", {})\n",
    "\n",
    "# ================= HELPERS =================\n",
    "\n",
    "def clean_numeric(s):\n",
    "    return pd.to_numeric(s, errors=\"coerce\")\n",
    "\n",
    "def engineer_features(df):\n",
    "    df = df.copy()\n",
    "\n",
    "    df[\"current\"] = df[\"current\"].clip(lower=0)\n",
    "\n",
    "    df[\"current_roll_mean\"] = df[\"current\"].rolling(ROLL_WIN).mean()\n",
    "    df[\"current_roll_std\"] = df[\"current\"].rolling(ROLL_WIN).std()\n",
    "    df[\"current_roll_min\"] = df[\"current\"].rolling(ROLL_WIN).min()\n",
    "    df[\"current_roll_max\"] = df[\"current\"].rolling(ROLL_WIN).max()\n",
    "\n",
    "    df[\"temp_roll_mean\"] = df[\"temperature\"].rolling(ROLL_WIN).mean()\n",
    "    df[\"temp_roll_std\"] = df[\"temperature\"].rolling(ROLL_WIN).std()\n",
    "\n",
    "    df[\"current_rate\"] = df[\"current\"].diff()\n",
    "    df[\"temp_rate\"] = df[\"temperature\"].diff()\n",
    "\n",
    "    df[\"current_lag1\"] = df[\"current\"].shift(1)\n",
    "    df[\"temp_lag1\"] = df[\"temperature\"].shift(1)\n",
    "\n",
    "    df[\"current_temp_ratio\"] = df[\"current\"] / df[\"temperature\"].replace(0, np.nan)\n",
    "    df[\"current_temp_product\"] = df[\"current\"] * df[\"temperature\"]\n",
    "\n",
    "    df = df.dropna(subset=feature_names)\n",
    "    return df\n",
    "\n",
    "def classify_anomalies(recon_errors, iso_preds, base):\n",
    "    counts = {\"critical\": 0, \"high\": 0, \"medium\": 0, \"low\": 0}\n",
    "\n",
    "    for i in range(len(recon_errors)):\n",
    "        curr = base.iloc[i][\"current\"]\n",
    "        temp = base.iloc[i][\"temperature\"]\n",
    "\n",
    "        is_anom = recon_errors[i] > ae_threshold or iso_preds[i] == -1\n",
    "        severity = \"low\"\n",
    "\n",
    "        if is_anom:\n",
    "            if curr >= current_thr.get(\"upper_critical\", 100) or temp >= temp_thr.get(\"upper_critical\", 80):\n",
    "                severity = \"critical\"\n",
    "            elif curr >= current_thr.get(\"upper_warning\", 2) or temp >= temp_thr.get(\"upper_warning\", 70):\n",
    "                severity = \"high\"\n",
    "            else:\n",
    "                severity = \"medium\"\n",
    "\n",
    "        counts[severity] += 1\n",
    "\n",
    "    return counts\n",
    "\n",
    "def generate_plot(df):\n",
    "    fig, ax = plt.subplots(figsize=(6, 4))\n",
    "    ax.plot(df.index, df[\"current\"], label=\"Current\")\n",
    "    ax.scatter(df[df[\"anomaly\"] == 1].index,\n",
    "               df[df[\"anomaly\"] == 1][\"current\"],\n",
    "               color=\"red\", label=\"Anomaly\")\n",
    "\n",
    "    ax.set_title(\"Battery Anomaly Summary\")\n",
    "    ax.legend()\n",
    "\n",
    "    buf = io.BytesIO()\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(buf, format=\"png\")\n",
    "    plt.close()\n",
    "    buf.seek(0)\n",
    "    return buf\n",
    "\n",
    "# ================= MAIN ENTRY POINT =================\n",
    "\n",
    "def run_inference(device_id: str | None = None):\n",
    "    df = pd.read_csv(DATASET_PATH)\n",
    "\n",
    "    df[\"current\"] = clean_numeric(df[\"current\"])\n",
    "    df[\"temperature\"] = clean_numeric(df[\"temperature\"])\n",
    "    df[\"parsed_datetime\"] = pd.to_datetime(df[\"datetime\"], errors=\"coerce\")\n",
    "\n",
    "    if device_id:\n",
    "        df = df[df[DEVICE_COLUMN] == device_id]\n",
    "\n",
    "    if df.empty:\n",
    "        raise ValueError(\"No data available for the given device\")\n",
    "\n",
    "    latest_time = df[\"parsed_datetime\"].max()\n",
    "    df = df[df[\"parsed_datetime\"] >= latest_time - timedelta(minutes=RECENT_DATA_WINDOW_MINUTES)]\n",
    "\n",
    "    df_feat = engineer_features(df)\n",
    "    X = scaler.transform(df_feat[feature_names].values)\n",
    "\n",
    "    recon = autoencoder.predict(X, verbose=0)\n",
    "    recon_errors = np.mean((X - recon) ** 2, axis=1)\n",
    "\n",
    "    iso_preds = isolation_forest.predict(X)\n",
    "\n",
    "    counts = classify_anomalies(recon_errors, iso_preds, df_feat[[\"current\", \"temperature\"]])\n",
    "\n",
    "    status = (\n",
    "        \"Immediate Action Required\"\n",
    "        if counts[\"critical\"] > 0\n",
    "        else \"Degradation Accelerating\"\n",
    "        if counts[\"high\"] > 3\n",
    "        else \"Moderate Irregularities\"\n",
    "        if counts[\"medium\"] > 0\n",
    "        else \"Stable\"\n",
    "    )\n",
    "\n",
    "    df_feat[\"anomaly\"] = ((recon_errors > ae_threshold) | (iso_preds == -1)).astype(int)\n",
    "\n",
    "    image = generate_plot(df_feat)\n",
    "\n",
    "    return {\n",
    "        \"device_id\": device_id or \"ALL\",\n",
    "        \"status\": status,\n",
    "        \"anomalies\": counts,\n",
    "        \"generated_at\": datetime.utcnow().isoformat(),\n",
    "        \"image\": image\n",
    "    }"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
